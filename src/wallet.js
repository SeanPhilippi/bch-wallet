const bitcore = require('bitcore-lib-cash');
const fetch = require('whatwg-fetch').fetch;

const DUST_LIMIT = 600;

function Wallet(privateKey) {
  if (privateKey) {
    // WIF = wallet import format
    this.privateKey = bitcore.PrivateKey.fromWIF(privateKey);
  } else {
    // create a completely random private key
    this.privateKey = new bitcore.PrivateKey();
  }
};

const estimateTransactionBytes = (inputCount, outputCount) => {
  // each input is going to consume roughly 149 bytes
  // the digital sig generated by the owner of the private key is generally 71-72 bytes
  // the bytes of the has of the public key among other things add up to roughly 149 bytes,
  // 149 being an overestimate so that the fee is never less than wanted.
  // 34 is a roughly amount of bytes for the hash of the public key
  return inputCount * 149 + outputCount * 34 + 10;
}

Wallet.prototype.getBalance = function getBalance() {
  return fetch(`https://rest.bitcoin.com/v2/address/details/${this.getDepositAddress()}`).then(
    res => {
      if (!res.ok) {
        throw new Error('Fetching balance failed. Please try again later.');
      }
      return res.json();
    }
  ).then(details => {
    console.log('details', details)
    // balanceSat is balance displayed in satoshis
    // adding unconfirmedBalanceSat because the balance value is just what has made it
    // into the blockchain because the blocks have been mined by miners adding
    // unconfirmedBalanceSat will give you what the real total will be once it's all on the blockchain
    return details.balanceSat + details.unconfirmedBalanceSat;
  });
}

Wallet.prototype.getDepositAddress = function getDepositAddress() {
  // public key is derived from the private key, and an address is just a
  // has of the user's private key
  return this.privateKey.toPublicKey().toAddress().toString();
}

Wallet.prototype.withdraw = function withdraw(address, amount) {
  // store this value here as self, since in the then() the
  // this value will no longer reference the Wallet
  const self = this;
  return fetch(`https://rest.bitcoin.com/v2/address/utxo/${this.getDepositAddress()}`).then(res => {
    if (!res.ok) {
      throw new Error('Fetching UTXOs failed. Please try again later.');
    }
    return res.json();
  }).then(res => {
    console.log('utxos', res.utxos)
    // balance is the sum of all the satoshis in our utxos
    // utxo = unspent transaction output
    const balance = res.utxos.reduce((acc, utxo) => acc + utxo.satoshis, 0);
    console.log('balance', balance)
    // make adjustable later
    // 1 or 2 outputs
    let minerFee1 = estimateTransactionBytes(res.utxos.length, 1); // * 5 would be 5 satoshis / byte
    let minerFee2 = estimateTransactionBytes(res.utxos.length, 2); // * 5 would be 5 satoshis / byte

    if (amount < DUST_LIMIT) {
      throw new Error('Output amount below dust limit.');
    }

    if (balance - amount < minerFee1) {
      throw new Error('Insufficient balance.');
    }

    let transaction = new bitcore.Transaction().from(utxos);

    if (balance - amount - minerFee2 < DUST_LIMIT) {
      transaction = transaction.to(address, amount);
    } else {
      transaction = transaction.to(address, amount);
      transaction = transaction.to(self.getDepositAddress(), balance - amount - minerFee2);
    }
    transaction = transaction.sign(self.privateKey);
    // grabs transaction object and produces a raw transaction from it
    // checks that it's been signed, etc, if not, it will fail
    const rawTransaction = transaction.checkedSerialize();
    return fetch(`https://rest.bitcoin.com/v2/rawtransactions/sendRawTransaction/${rawTransaction}`, {
      method: 'POST',
    })
  }).then(res => {
    if (!res.ok) {
      throw new Error('Broadcasting tranaction failed. Please try again later.');
    }
    return res.text();
  }).then(text => {
    // test whether the text contains a valid transaction id
    if (text.match(/^"[0-9a-fA-F]{64}"$/) === null) {
      throw new Error(`Broadcasting transaction failed with error: ${text}. Please try again.`);
    }
    // valid transaction id
    return text;
  })
}

Wallet.prototype.getPrivateKey = function getPrivateKey() {
  // WIF is wallet import format, converts key which is an array of bytes
  // to a string that is easier to store and write down.;
  return this.privateKey.toWIF();
}

module.exports = Wallet;